
using LinearAlgebra, HomotopyContinuation, Oscar

struct Aux_data{T}
    A::Matrix{T}            # Input matrix. Full rank and all ones vector is in rowspan.
    d::Int              # number of rows of A
    n::Int                # number of columns of a
    B::Matrix{T}         # Gale dual to A
    U::Matrix{T}         # transform of the smith normal form S: U S V = B
    Π::Matrix{T}         # first n-d columns of U. Defines a projection onto the kernel of A.
    Π_rinv::Matrix{T}    # the first n-d rows of U^-1, a right-inverse to \Pi.
    matroid   # the matroid associated to B
    ΣB        # the Bergman fan associated to B
    Γ         # Inverses of the coefficient matrices for each cone σ and each standard basis vector e_i
    dets      # For each cone σ and each standard basis vector e_i, the determinant of the coefficient matrix of our linear system
    RR        # matrices with Z-bases for the lattices generated by all the cones
    Fσ        # matrices F such that σ = { F x <= 0 } for all cones σ
end

function data_from_matrix(A::Matrix{Int})
    d, n = size(A)
    S = MatrixSpace(ZZ, d, n)
    B = nullspace(S(A))[2]
    S,U,V = snf_with_transform(B)
    Π = Matrix{Int64}(U[1:n-d, :])
    B = Matrix{Int64}(B)
    Π_rinv  = Matrix{Int64}(inv(U))[:,1:n-d]
    U = Matrix{Int64}(U)
    matroid = Polymake.matroid.Matroid(VECTORS = B)
    ΣB = Polymake.tropical.matroid_fan{min}(matroid)
    Γ, dets, RR, Fσ = getConeData(A, ΣB)
    Aux_data(A, d, n, B, U, Π, Π_rinv, matroid, ΣB, Γ, dets, RR, Fσ)
end



for i = 1:n
    for j = 1:size(Γ,1)
        if dets[j,i] != 0
            x = Array(Γ[j,i]*w)
            if minimum(abs.(x)) == 0
                if warning
                    println("non-generic for w = $w !")
                end
                flag = true
            end
            if x[end] > 0 && prod(Fσ[j]*(RR[j]*x[1:size(RR[j],2)]) .< 0) == 1
                monomial[i] += dets[j,i]
            end
        end
    end
end



function cone_containments(w, data::Aux_data)
    n = data.n
    is_contained = zeros(Int64,n, size(data.Γ, 1))
    is_in_face = zeros(Int64, n, size(data.Γ, 1))
    for i = 1:n
        for j = 1:size(data.Γ,1)
            if data.dets[j, i] != 0
                x = Array(data.Γ[j,i])*Array(w)
                if x[end]≥0
                    vec = -data.Fσ[j]*(data.RR[j]*x[1:size(data.RR[j],2)])
                    if all(vec.≥0)
                        is_contained[i, j] = 1
                        if sum(vec.==0) > 0 || x[end] > 0
                            is_in_face[i, j] = 1
                        end
                    end
                end
            end
        end
    end
    is_contained, is_in_face
end

function getVertex(w, data::Aux_data)
    n = data.n

    monomial = zeros(fmpq,n)
    is_contained, is_in_face = cone_containments(w, data)
    is_generic = sum(is_in_face) == 0

    if !(is_generic)
        println("w is not generic: w = $w")
        w_new = 2000 * w + rand(-100:100, n)
        is_contained_new, is_in_face_new = cone_containments(w_new, data)
        while is_contained_new != is_contained
            w_new = 2000 * w + rand(-100:100, n)
        end
        is_contained = is_contained_new
    end

    for i = 1:n
        for j = 1:size(data.Γ,1)
            if data.dets[j,i] != 0
                if is_contained[i, j] == 1
                    monomial[i] += data.dets[j,i]
                end
            end
        end
    end

    monomial
end





A = [0 1 0 1 2 1; 0 0 1 1 1 2; 1 1 1 1 1 1]

A = [1 1 1 1 1 1;
0 1 2 0 1 0;
0 0 0 1 1 2]

A =
[
3 2 2 1 1 1 0 0 0 0;
0 1 0 2 1 0 3 2 1 0;
1 1 1 1 1 1 1 1 1 1]

A = [1 1 1 1 1 1  1 1 1 1 1 1;
      0 0 0 0 0 0  1 1 1 1 1 1;
      0 0 0 1 1 2 0 0 0 1 1 2;
      0 1 2 0 1 0 0 1 2 0 1 0]


data = data_from_matrix(A)
V_0 = sampleRandom2(data, 5)
V_0 = sampleRandom(data, 5)

nsamples = 10
n = data.n
for i = 1:nsamples
    w = rand(-10000:10000,n)
    is_contained, is_in_face = cone_containments(w, data)
    bool = sum(is_in_face.==1) == 0
    println("is generic: $bool")
    #monomial = getVertex(w, data)
    #monomials = unique!(push!(monomials,monomial))
end


P = convex_hull(hcat(V_0...)')
v_0, vtcs, fcts, Pol = newton_pol(A, B, Π)
disc, B, coeff, mons, err_tol = interpolate_discr(A)

verify(disc, mons, coeff, A, B; strategy = "interpolation")



#println(V_new)
#rand_verts  = sampleRandom(Γ, dets, RR, Fσ, 1000)
#P = convex_hull(  hcat(rand_verts...)'  )
#l_points  = lattice_points(P)
#verts = vertices(P)
#
#rand_verts_proj = [Π*(v-rand_verts[1]) for v in rand_verts]
##rand_verts_proj = [Π*(v-v_0) for v in rand_verts]
#P_proj = convex_hull( (hcat(rand_verts_proj...)'))
#l_points_proj  = lattice_points(P_proj)
#verts_proj = vertices(P_proj)
